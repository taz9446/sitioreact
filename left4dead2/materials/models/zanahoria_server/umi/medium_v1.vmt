"VertexLitGeneric"
{
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    ___  ___      _      _       ___  ___ ____ ____ ___   ___      _      __     __      _      ___ ___     ___ __  ___ __     
//   |   _  \   __|  /_\   |   |    |_   _/   __|_    _|_   _/  __|   |      \  /_\    |     \/     |   /_\   / __|   __|   |_     )     \_    )    \   
//   |       /   _|  /  _  \ |   |__  |   |\__  \    |   |    |   |   (__     |   |)  /  _  \  |    |\/|    | /  _   \  (_  |   _|       /  /  ( )   /   / ( )  |
//   |__|_\___/_/   \_\____|___|___/    |_|   |___\___|   |___/_/   \_\ _ |    |_ /_/   \_\___|___|   /___\__/___\__/
//
//  ++++++++++++++++++++++++++++++++++  MEDIUM VERSION (V1) +++++++++++++++++++++++++++++++++  
//
//  By Ellie, ask your questions here : https://steamcommunity.com/id/ellie_williams/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  DEFAULT VARIABLES
//
//  These variables are defined by default here. Most of them will probably be changed by the user, but they are here as a safe net in case one is forgotten	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	$alpha			"1"					// This is if this VMT must show or not by default (0 = is invisible ; 1 = is visible (default))
	$detail 			"models/zanahoria_server/umi/ProgressiveNoHands_darker"	// This is the Bloodmap that will be used for this VMT or this is the Burn/Vomit map if $basetexture has the blood

	$frame0ifbelow		"100"	// Display frame 0 if the survivor is below that amount of health
	$frame1ifbelow		"90"	// Display frame 1 if the survivor is below that amount of health
	$frame2ifbelow		"70"	// Display frame 2 if the survivor is below that amount of health
	$frame3ifbelow		"40"	// Display frame 3 if the survivor is below that amount of health
	$frame4ifbelow		"20"	// Display frame 4 if the survivor is below that amount of health
	$frame5ifbelow		"10"	// Display frame 5 if the survivor is below that amount of health
	$frame6ifbelow		"-1"	// Display frame 6 if the survivor is below that amount of health
	$frame7ifbelow		"-1"	// Display frame 7 if the survivor is below that amount of health
	$frame8ifbelow		"-1"	// Display frame 8 if the survivor is below that amount of health

	$frameIfDown		"6"	// Set the frame to display when the survivor is down (it can be one of the above)

	$canOnlyGetWorse		"0"	// Can the Realistic Damage disappear if the survivor uses a Medkit ? (0 = yes ; 1 = no)

	$randomBloodPosition	"0"	// Will the blood/vomit/scorch stains have a randomized position? (0 = no ; 1 = yes) 
	$randomBloodAngle		"0"	// Will the blood/vomit/scorch stains have a randomized angle ? (0 = no ; 1 = yes) 

	$ScaleDET		"0.125"	// Scale of the blood/burn/vomit texture. The bigger it is, the smaller it will be. You can input [256 divided by your basetexture width] to make them match size.
	$CenterDET		"0.5"	// Center of rotation of the blood/burn/vomit texture, you should normally not change that
	$RotateDET		"0.0"	// Rotation of the blood/burn/vomit texture in degrees. Can be used if no RNG to position the texture precisely.
	$TranslationDET		"0.0"	// Translation of the blood/burn/vomit texture. 0.25 = 25%, shift, 0.5 = 50% shift, 0.75 = 75% shift, 1 = 100% shift, which is the same as 0% shift.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The values in the next block are only useful if you want texture RNG (=/= blood RNG). 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	$differentSkins		"0"	// Amount of different skins you have and you want to RNG for the clothes under the blood (0 = RNG for clothes is deactivated)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The values in the next block are only useful if you want to show 3D wounds / hide 3D destroyed armor
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	$showIfBelowThisHP	"400"	// The whole texture will be invisible if the HP is above this value (default = 400 HP, because some servers allow higher max HP)
	$butNotIfBelowThisHP	"-1"	// The whole texture will be invisible if the HP is below this value (default (if not in use) is -1)

	$alphaIfDown		"1"	// What to display (alpha) when the survivor is down (0 = invisible ; 1 = visible)
	$alphaIfDownMaxPriority	"0"	// Does the code has to use the above value no matter what? (0 = no; 1 = yes)
	
	$cannotRevertDefaultAlpha	"0"	// Can the whole material (alpha) appear again / disappear again after he changed status (0 = yes ; 1 = no) ? Useful only if $butNotIfBelowThisHP is not set to -1

	$chanceOfChanging	"100"	// % of chance that the visibility (alpha) change will occur (default = 100); can be used to RNG the loss of clothes or armor or the gain of wounds

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The values in the next block are only useful for debug and testing purposes
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	$scrollShowcase		"0"	// Debug feature to scroll through different $detail. Set the number to the amount of different blood levels the $detail you're using has (does not worth if you have custom blood textures painted over the diffuse)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The next value should normally not be changed, unless you did a mistake
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	$detailblendmode		"0"	// $detail blend mode. Should normally be set to 0. Do not change it unless you know what you're doing.
	$shinyblood		"0"	// Gives a better look to the blood

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY ANYTHING BELOW THIS
// DO NOT MODIFY ANYTHING BELOW THIS
// DO NOT MODIFY ANYTHING BELOW THIS
// DO NOT MODIFY ANYTHING BELOW THIS
// DO NOT MODIFY ANYTHING BELOW THIS
// DO NOT MODIFY ANYTHING BELOW THIS
// DO NOT MODIFY ANYTHING BELOW THIS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	

	$detailtexturetransform	"center .5 .5 scale 1 1 rotate 0 translate 0 0"	// Initiatlisation of the detail position variable (engine)
	$detailblendfactor		"1"					// Initiatlisation of the detail blend factor (engine)
	$detailframe		"0"					// Initiatlisation of the detailframe (engine)
	$frame			"0"					// Initiatlisation of the frame (engine)

	$blendTintByBaseAlpha 	"0"	// Failstate if colorRNG needs to be used with other VMTs that do not have it
		
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  CODE VARIABLES
//  These variables are the ones the code will use. The user is not supposed to change any of them. Any change can result in the code breaking	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Numerical variables
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	$moo		.01
	$mo		"-1"
	$zero		"0"
	$one		"1.0"
	$onn		"1.98"
	$two		"2"
	$three		"3"
	$four		"4"
	$five		"5"
	$six		"6"
	$seven		"7"
	$eight		"8"
	$oh		"100"
	$oho		"101"

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Variables for BLOCK 2 - Blood effect manipulation
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	$rand		"0.0"	// Used to store a random number to shift and rotate the blood effect accordingly
	$randFixed	"0.0"	// Used to store a random number only once. Must be initiated to 0.

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Variables for BLOCK 3 - Retrieve data
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	$sine		"0"	// This is used just to store a sine wave (used as a buffer)

//-------------------------- Health related

	$scale		"100"	

	$healthCurrent	"100"	// This is used to store the % of health the survivor currently has (note that the "health" is 100 if the survivor is down)
	$worstHealth	"100"	// This is used to store the worst health the survivor has had during the map. Useful if $canOnlyGetWorse is set to 1
	$healthPercent	"100"	// This is a temporary variable used to make comparisons to find the correct frame to display (either $healthCurrent or $worstHealth is injected into)

	$hasTakenDamage	"0"	// This is used to store if the survivor has ever been below 100 health (0 = no ; 1 = yes)

	$noInjectWorstHealth	0	// This is used to prevent the injection of the health level if it is 0
	$worstHealthToInject	0	// This is used as temporary storage
	$mustHeal		0	// This is used to know if the survivor still must heal after being down
		
	$mapRestartTPK		0	// This is used to know if the map restarted after a TPK on the first map of the campaign

//-------------------------- Speed related

	$ismoving		"0"	// This is used to store if the entity is moving (0.0000 = no, 0.0001+ = yes)
	$playerSpeed	"0"	// This is used to store the player speed itself (and not the entity or survivor speed)

//-------------------------- Position related

	$pos 			"[0 0 0]"	// Used to store the position of the player when he spawns

	$posX			.0	// The X coordinate position of the player
	$posXStored		.0	// The X position of the player stored when he first spawned

	$posY			.0	// Ditto Y coordinate
	$posYStored		.0

	$posZ			.0	// Ditto Z coordinate
	$posZStored		.0

	$entityorigin		"[0 0 0]"	// Engine variable that tells the material origin when the corresponding Proxy sets it

	$posXDELTA	.0	// Used to store the difference between the current and starting position (X coordinate)
	$posYDELTA	.0	// Ditto Y coordinate
	$posZDELTA	.0	// Ditto Z coordinate
	$posTOLERANCE	600.0	// [CRITICAL] : If the player is this units away from spawn, he'll be considered out of spawn
	$isNearTheStart	"0"	// Used to determine if the player is near the place where the survivor spawned

//-------------------------- Time related

	$serverTime		"0.0"	// This is used to know if the server just started
	$ENTJustSpawned		"0"	// Time value to know if the entity just spawned

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Variable for BLOCK 4 - Get Frame to display
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	$frametodisplay	"0"	// This is used to store the frame we need to display after it has been "identified" according to the comparison health

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Variable for BLOCK 5 - Check if down
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	$isdown		"0"	// This is used to store the status of the survivor (0 = up and walking) (1 = downed but still alive)

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Variable for BLOCK 6 - Injector Detailblendfactor
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	$dbfToInject	"0.0"	// This is used to store the starting hypothesis for what $detailblendfactor will be

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Variable for BLOCK 7 - Injector Frame and Detailframe
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	$frameIsEntity	"0"		// This is used to make comparisons (temp value)
	$frametoinjectTemp		"0"	// This is used to make comparisons (temp value)	
	$detailframetoinjectTemp 	"0"	// This is used to make comparisons (temp value)

	$frametoinject	"0"	// This is used to store the frame we need to display
	$detailframetoinject	"0"	// This is used to store the detailframe we need to display

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Variables for BLOCK 8 - Injector of $alpha
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	$alphatodisplay		"0"	// This store the first hypothesis for what $alpha to display according to the current health

//-------------------------- Temp values for fMod()

	$posYINT 		.0
	$posYD  			.0
	$posYDFRAC		.0

//---------------------------- Temp values for RNG

	$randUN			"0.0"	// This is the result of fMod100($posX) 
	$randChange		"0.0"	// This is used to store the result of the $randUN once every 2 seconds
	$randChangeStored		"101"	// [Default = 101] This is the RNG number used to determine if the VMT must go visible or invisible if it is random
	$rerollifabove		"0.0"	// This is used to store the health value over which the code has to reroll the RNG (for the next time the health will go down)
	
//-------------------------------------------------------------

	$healthSpecial		"100"	// This is used as a temporary variable to make a comparison

	$alphaRNGChecked	"0"	// This is used to make comparisons (temp value)
	$alphaEntityChecked	"0"	// This is used to make comparisons (temp value)
	$alphaNRChecked		"0"	// This is used to make comparisons (temp value)

	$showFromStart		"0"	// This is used for the code to store if the VMT is visible from the start or not	
	$alphaHasChanged		"0"	// This is used to store if the $alpha has changed (to maybe prevent it from reverting)
	
	$forceSameAlpha		"0"	// If this is set to 1 by the code, the same $alpha has to be injected
	$forceDownAlpha		"0"	// This is used by the code to force the $alpha the user specified when a survivor is down if the user told it to

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Variables for BLOCK 9 - RNG $basetexture
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	$randRNG		"0"	// This is used to store the drawn RNG number associated with the entity
	$frameRNG		"0"	// This is used to store the frame to maybe display for the RNG block

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PROXIES
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Proxies	// Do not delete this line
{

// #######################################################################################################
// BLOCK 2 : RANDOM BLOOD ANGLE & POSITION - If toggled by the user, modifies the angle and position of the $detail to give RNG blood
// #######################################################################################################
// ========================================================================================================================
// Gets a random number between 0 and 359, only once, then injects it into the translation and rotate variables if the user activated the effect
// ========================================================================================================================

	EntityRandom		// Stores a random number from 0 to 359 (359 is needed to have all the possible rotation angles)
	{
		scale 		359 
		resultVar 		"$rand"
	}

	LessOrEqual		// Ensures that the number is stored only once by putting it in $randFixed only if it has (still) its initial value of 0
	{
		LessEqualVar 	"$rand" 
		greaterVar 	"$randFixed"
		srcVar1		"$randFixed"
		srcVar2		"$zero"
		resultVar		"$randFixed"
	}

	LessOrEqual		// If $randomBloodPosition is higher than 0, injects the random number into the Translation variable
	{
		LessEqualVar 	"$TranslationDET" 
		greaterVar 	"$randFixed"
		srcVar1		"$randomBloodPosition"
		srcVar2		"$zero"
		resultVar		"$TranslationDET"		

		// N.b. the only thing that matters for the translation is the decimal part of the random number.
	}

	LessOrEqual		// If $randomBloodAngle is higher than 0, injects the random number into the Rotation variable
	{
		LessEqualVar 	"$TranslationDET" 
		greaterVar 	"$randFixed"
		srcVar1		"$randomBloodAngle"
		srcVar2		"$zero"
		resultVar		"$RotateDET"
	}

	TextureTransform		// Injects the values (either user defined and/or randomized) into $detailtexturetransform (engine variable)
	{
		centerVar		"$CenterDET"
		scaleVar		"$ScaleDET"
		rotateVar		"$RotateDET"
		translateVar	"$TranslationDET"
		resultVar		"$detailtexturetransform"	// This is a FINAL INJECTION, the value is not used afterwards.
	}

// ========================================================================================================================
// BLOCK 3 : PARAMETERS IMPORT - This block imports parameters from within the game 
// ========================================================================================================================
// ========================================================================================================================
// This blocks generates a sine wave, that goes from -1 to 2 to -1 in 2 seconds
// ========================================================================================================================

	Sine			// Sine wave, that goes from -1 to 2 to -1 in 2 seconds								
	{
		sineperiod	"$two"
		sinemin		"$mo"
		sinemax		"$two"
		resultVar		"$sine"
	}			
		// N.b. This is used at various places in the code to create buffers while checking if conditions are met only once per second instead of all the time

// ========================================================================================================================
// This blocks gets the current position of the player
// ========================================================================================================================

        	PlayerPosition		// Stores the player position in a matrix
        	{
                	scale                    	1
                	resultVar               	"$pos"
        	}

        	Clamp			// Sends the first row of the position matrix into a $poxX variable 
        	{
		srcVar1		"$zero"
		min		"$pos[0]"
		max		"$pos[0]"
		resultVar		"$posX"	
        	}

        	Clamp			// Sends the first row of the position matrix into a $poxY variable 
        	{
		srcVar1		"$zero"
		min		"$pos[1]"
		max		"$pos[1]"
		resultVar		"$posY"	
        	}

        	Clamp			// Sends the first row of the position matrix into a $poxZ variable 
        	{
		srcVar1		"$zero"
		min		"$pos[2]"
		max		"$pos[2]"
		resultVar		"$posZ"	
        	}


	Abs			// Makes sure the position is positive
	{
		srcVar1		"$posX"
		resultVar		"$posX"	
	}

	Abs			// Makes sure the position is positive
	{
		srcVar1		"$posY"
		resultVar		"$posY"	
	}	

	Abs			// Makes sure the position is positive
	{
		srcVar1		"$posZ"
		resultVar		"$posZ"	
	}	


	LessOrEqual		// Stores the X coordinate only once when the player spawns
	{
		LessEqualVar 	"$posX" 
		greaterVar 	"$posXStored"
		srcVar1		"$posXStored"
		srcVar2		"$zero"
		resultVar		"$posXStored"
	}


	LessOrEqual		// Stores the Y coordinate only once when the player spawns
	{
		LessEqualVar 	"$posY" 
		greaterVar 	"$posYStored"
		srcVar1		"$posYStored"
		srcVar2		"$zero"
		resultVar		"$posYStored"
	}


	LessOrEqual		// Stores the Z coordinate only once when the player spawns
	{
		LessEqualVar 	"$posZ" 
		greaterVar 	"$posZStored"
		srcVar1		"$posZStored"
		srcVar2		"$zero"
		resultVar		"$posZStored"
	}


// ========================================================================================================================
// This blocks gets the difference between the origin and current position of the player and check if it's at least $posTOLERANCE units away in any direction
// ========================================================================================================================

	Subtract			// Getting the position difference on X axis
	{
		srcVar1		"$posXStored"
		srcVar2		"$posX"
		resultVar		"$posXDELTA"
	}

	Subtract			// Getting the position difference on Y axis
	{
		srcVar1		"$posYStored"
		srcVar2		"$posY"
		resultVar		"$posYDELTA"
	}

	Subtract			// Getting the position difference on Z axis
	{
		srcVar1		"$posZStored"
		srcVar2		"$posZ"
		resultVar		"$posZDELTA"
	}

        	Abs			// Making the difference positive for the comparison below
        	{
		srcVar1		"$posXDELTA"
		resultVar		"$posXDELTA"	
        	}

        	Abs			// Making the difference positive for the comparison below
        	{
		srcVar1		"$posYDELTA"
		resultVar		"$posYDELTA"	
        	}

        	Abs			// Making the difference positive for the comparison below
        	{
		srcVar1		"$posZDELTA"
		resultVar		"$posZDELTA"	
        	}

	LessOrEqual		// If the difference between the values (X axis) is less than $posTOLERANCE, we are near the start
	{
		LessEqualVar 	"$one" 
		greaterVar 	"$zero"
		srcVar1		"$posXDELTA"
		srcVar2		"$posTOLERANCE"
		resultVar		"$isNearTheStart"
	}

	LessOrEqual		// Ditto check for Y axis. If the position isn't near, it flags $isNearTheStart to 0
	{
		LessEqualVar 	"$isNearTheStart" 
		greaterVar 	"$zero"
		srcVar1		"$posYDELTA"
		srcVar2		"$posTOLERANCE"
		resultVar		"$isNearTheStart"
	}

	LessOrEqual		// Ditto check for Y axis. If the position isn't near, it flags $isNearTheStart to 1
	{
		LessEqualVar 	"$isNearTheStart" 
		greaterVar 	"$zero"
		srcVar1		"$posZDELTA"
		srcVar2		"$posTOLERANCE"
		resultVar		"$isNearTheStart"
	}

// ========================================================================================================================
// This blocks gets the % of health the survivor currently has (in $healthCurrent) and scales it to match 100 (default is between 0 and 1)
// ========================================================================================================================

	Health
	{
		scale 		"$scale" 
		resultVar 		"$healthCurrent"		// This is used immediadly after to calculate the worst health
							// This is also used later in the code to make various comparisons
	}

	// N.b. This gets the value of the "real" health the survivor has. The decaying health (after eating pain pills or adrenaline) doesn't count.
	// N.b. This goes to 400 when the survivor is down but is automatically clamped to 100. Therefore, when the survivor goes goes, its "health" goes to 100

// ========================================================================================================================
// This blocks gets a timing value related to the server active time
// ========================================================================================================================

	CurrentTime
	{
		resultVar 		"$serverTime"
	}

// ========================================================================================================================
// This blocks gets the worst health level the survivor has ever had since the beginning of the map
// ========================================================================================================================

	LessOrEqual		// If the health is 0.00, it should not be injected, because it's a "fake" health given by the FPS arms or the dead corpse
	{
		LessEqualVar 	"$one" 
		greaterVar 	"$zero"
		srcVar1		"$healthCurrent"
		srcVar2		"$zero"
		resultVar		"$noInjectWorstHealth"
	}

	LessOrEqual		// Stores the current health in $worstHealthToInject only if it's worse than the worst health ever 
	{
		LessEqualVar 	"$healthCurrent" 
		greaterVar 	"$worstHealth"
		srcVar1		"$healthCurrent"
		srcVar2		"$worstHealth"
		resultVar		"$worstHealthToInject"
	}

	LessOrEqual		// Actually does the final storage only if $noInjectWorstHealth is equal to 0
	{
		LessEqualVar 	"$worstHealthToInject" 
		greaterVar 	"$worstHealth"
		srcVar1		"$noInjectWorstHealth"
		srcVar2		"$zero"
		resultVar		"$worstHealth"
	}

// ========================================================================================================================
// This blocks gets the speed the entity (survivor) and the player currently have
// ========================================================================================================================

	EntitySpeed		// This gets the speed of the surviror and stores it into $ismoving
	{
		resultVar		"$ismoving" 		// This is later used to determine if the survivor is down or not in BLOCK #
	}	

	PlayerSpeed		// This gets the speed of the player and stores it into $playerSpeed
	{
		resultVar		"$playerSpeed"		// This is later used to determine if the player is down or not in BLOCK #
	}


	// N.b. The speed itself doesn't matter in this code. The only thing that matters is the survivor is moving, so if its speed is above 0

// ========================================================================================================================
// This blocks tries to guess if the player has taken damage already
// ========================================================================================================================

	LessOrEqual		// If the survivor health is bigger than 100, the $hasTakenDamage is reset to zero
	{
		LessEqualVar 	"$hasTakenDamage" 
		greaterVar 	"$zero"
		srcVar1		"$healthCurrent"
		srcVar2		"$oh"
		resultVar		"$hasTakenDamage"
	}
				// N.b. this should normally not occur, but as some L4D2 custom servers allow HP above 100. 
				
	LessOrEqual		// If the worst health the survivor had is lower than 100, the survivor has taken damage (pretty straightforward)
	{
		LessEqualVar 	"$hasTakenDamage" 
		greaterVar 	"$one"
		srcVar1		"$oh"
		srcVar2		"$worstHealth"
		resultVar		"$hasTakenDamage"	// This value is used later in BLOCK 5 to check if the survivor is down
	}	

// ========================================================================================================================
// This blocks checks if the map reloaded after a TPK
// ========================================================================================================================

	LessOrEqual		// TPK at first map if we are now at 100 HP....
	{
		LessEqualVar 	"$one" 
		greaterVar 	"$zero"
		srcVar1		"$oh"
		srcVar2		"$healthCurrent"
		resultVar		"$mapRestartTPK"
	}

	LessOrEqual		// ... near the start of the map...
	{
		LessEqualVar 	"$zero" 
		greaterVar 	"$mapRestartTPK"
		srcVar1		"$isNearTheStart"
		srcVar2		"$zero"
		resultVar		"$mapRestartTPK"
	}

	LessOrEqual		// ... after 100 seconds have already passed
	{
		LessEqualVar 	"$zero" 
		greaterVar 	"$mapRestartTPK"
		srcVar1		"$serverTime"
		srcVar2		"$oh"
		resultVar		"$mapRestartTPK"
	}

// #######################################################################################################
// BLOCK 4 : IDENTIFY THE FRAME TO INJECT - This block aims to get the correct $frame (or $detailframe) to inject.
// #######################################################################################################
// ========================================================================================================================
// This blocks determines if we'll display the frame using the current health of the survivor ($healthCurrent) or the worst he ever had ($worstHealth)
// ========================================================================================================================

				// Before doing any comparison, reset the $worstHealth to 100 if we are in a $mapRestartTPK scenario
				// This fixes the glitch that occurs when there's a map restart on the first map after a TPK (total party kill)
	LessOrEqual		
	{
		LessEqualVar 	"$worstHealth" 
		greaterVar 	"$oh"
		srcVar1		"$mapRestartTPK"
		srcVar2		"$zero"
		resultVar		"$worstHealth"
	}

	LessOrEqual		
	{
		LessEqualVar 	"$hasTakenDamage" 
		greaterVar 	"$zero"
		srcVar1		"$mapRestartTPK"
		srcVar2		"$zero"
		resultVar		"$hasTakenDamage"
	}

	LessOrEqual		// If the user set $canOnlyGetWorse to 1 (above 0, we will use $worstHealth and otherwise the real current health)
	{
		LessEqualVar 	"$healthCurrent" 
		greaterVar 	"$worstHealth"
		srcVar1		"$canOnlyGetWorse"	// This is user defined
		srcVar2		"$zero"
		resultVar		"$healthPercent"		// This value is used immediatly after and only to identify the frame for the injection
	}

// ========================================================================================================================
// This block goes one by one through all the user defined $frameXifbelow and compares it to $healthPercent, updaring $frametodisplay each time accordingly
// ========================================================================================================================

	// The code starts at $frame0ifbelow. If the health used for the comparison is equal or smaller to the value of $frame0ifbelow, the $frametodisplay is set to 
	// 0 since it's the frame it is currently looking at. The code then does the same for $frame1ifbelow and replaces the value of $frametodisplay if the health 
	// is equal or smaller to the value of $frame1ifbelow, but this time by a 1 since since it's the frame it is currently looking at. When the condition will not be
	// met because the health is too big, the $frametodisplay will stay the same and will have the correct frame value

	LessOrEqual		// If $healthPercent < or = $frame0ifbelow, $frametodisplay = 0
	{
		LessEqualVar 	"$zero" 
		greaterVar 	"$frametodisplay"
		srcVar1		"$healthPercent"
		srcVar2		"$frame0ifbelow"
		resultVar		"$frametodisplay"
	}

	LessOrEqual		// If $healthPercent < or = $frame1ifbelow, $frametodisplay = 1
	{
		LessEqualVar 	"$one" 
		greaterVar 	"$frametodisplay"
		srcVar1		"$healthPercent"
		srcVar2		"$frame1ifbelow"
		resultVar		"$frametodisplay"
	}

	LessOrEqual		// If $healthPercent < or = $frame2ifbelow, $frametodisplay = 2
	{
		LessEqualVar 	"$two" 
		greaterVar 	"$frametodisplay"
		srcVar1		"$healthPercent"
		srcVar2		"$frame2ifbelow"
		resultVar		"$frametodisplay"
	}

	LessOrEqual		// If $healthPercent < or = $frame3ifbelow, $frametodisplay = 3
	{
		LessEqualVar 	"$three" 
		greaterVar 	"$frametodisplay"
		srcVar1		"$healthPercent"
		srcVar2		"$frame3ifbelow"
		resultVar		"$frametodisplay"
	}

	LessOrEqual		// If $healthPercent < or = $frame4ifbelow, $frametodisplay = 4
	{
		LessEqualVar 	"$four" 
		greaterVar 	"$frametodisplay"
		srcVar1		"$healthPercent"
		srcVar2		"$frame4ifbelow"
		resultVar		"$frametodisplay"
	}

	LessOrEqual		// If $healthPercent < or = $frame5ifbelow, $frametodisplay = 5
	{
		LessEqualVar 	"$five" 
		greaterVar 	"$frametodisplay"
		srcVar1		"$healthPercent"
		srcVar2		"$frame5ifbelow"
		resultVar		"$frametodisplay"
	}

	LessOrEqual		// If $healthPercent < or = $frame6ifbelow, $frametodisplay = 6
	{
		LessEqualVar 	"$six" 
		greaterVar 	"$frametodisplay"
		srcVar1		"$healthPercent"
		srcVar2		"$frame6ifbelow"
		resultVar		"$frametodisplay"
	}

	LessOrEqual		// If $healthPercent < or = $frame7ifbelow, $frametodisplay = 7
	{
		LessEqualVar 	"$seven" 
		greaterVar 	"$frametodisplay"
		srcVar1		"$healthPercent"
		srcVar2		"$frame7ifbelow"
		resultVar		"$frametodisplay"
	}

	LessOrEqual		// If $healthPercent < or = $frame7ifbelow, $frametodisplay = 8
	{
		LessEqualVar 	"$eight" 
		greaterVar 	"$frametodisplay"
		srcVar1		"$healthPercent"
		srcVar2		"$frame8ifbelow"
		resultVar		"$frametodisplay"		// This final result is CRITICAL and will serve as the base value for the injection in BLOCK 7
	}
	
// #######################################################################################################
// BLOCK 5 : IDENTIFY IF THE SURVIVOR IS DOWN - this block tries to guess if the survivor is down and returns the value in $isdown (1 = it is down)
// #######################################################################################################
// ========================================================================================================================
// Check if the PLAYER (=/= the Entity that has the blood on it) speed is above 0 (if the player moves)
// ========================================================================================================================

	// The block starts with the value of $isdown as it was last time the code was run through, then passes it into a bunch of checks that have a certain priority order

	LessOrEqual		// The first check is if the PLAYER speed is above 0 (even if the player is not playing the survivor that has the code on it). If it is, the survivor $isdown value is set to 0
	{
		LessEqualVar 	"$isdown" 
		greaterVar 	"$zero"
		srcVar1		"$playerSpeed"
		srcVar2		"$zero"
		resultVar		"$isdown"
	}	
				// N.b. this condition seems strange, because it is actually "if the PLAYER moves, his TEAMMATE is not down". It is true, but this is only useful to start the value that
				// will later be modified. Has this been at the end of this block (or after the injection of $hasTakenDamage), it would have caused problems.
				// The reason why this is is that if the player plays the survivor that has the code, $ismoving will never be above 1 because each time the game goes into 3rd person
				// (the only way to store $ismoving), the survivor is static, since he's either restrained by an infected or healing with a kit. Therefore, it resets it to 0
				// Also, when in third person mode, as the speed will always be 0, this will just inject the previous $isdown value

// ========================================================================================================================
// Check if the ENTITY has taken damage so far or if it is still at 100% health
// ========================================================================================================================		

	LessOrEqual		// This checks if the current health of the survivor is above 100. If it is not, it injects the result of $hasTakenDamage (see end of BLOCK 3)
	{			// This is the only way to inject a 1 into $isdown.

		LessEqualVar 	"$hasTakenDamage" 
		greaterVar 	"$isdown"
		srcVar1		"$oh"
		srcVar2		"$healthCurrent"
		resultVar		"$isdown"
	}	

	// The above proxy fixes the problem that occurs because when a surviror is down, it actually starts his "downed" phase with 100 HP
	// To fix this issue, we can use the fact that it's impossible for a surviror to go back to 100 HP once he has lower than this amount
	// If the player has never taken damage, and always had 100 HP, $hasTakenDamage = 0, and therefore, we inject that into $isdown when we have 100 HP
	// However, if the player has taken damage, and has now 100 HP, this can only mean he is under the influence of the special HP pool when he is down. In this
	// case, $hasTakenDamage will have a value of 1, and this is what will be copied into $isdown
	// If the player has MORE than 100 HP, he used cheats or is on a modder server, but in any case he's alive. Therefore, in this case, $isdown should stay the same as it was

// ========================================================================================================================
// Check if the survivor has healed since he went down
// ========================================================================================================================		

	LessOrEqual		// When the survivor goes down, it sets a flag that he should heal
	{
		LessEqualVar 	"$mustHeal" 
		greaterVar 	"$one"
		srcVar1		"$isdown"
		srcVar2		"$zero"
		resultVar		"$mustHeal"
	}	

	LessOrEqual		// The survivor "heals" when he can move again
	{
		LessEqualVar 	"$mustHeal" 
		greaterVar 	"$zero"
		srcVar1		"$ismoving"
		srcVar2		"$zero"
		resultVar		"$mustHeal"
	}

	LessOrEqual		// If the survivor must heal, he is down
	{
		LessEqualVar 	"$isdown" 
		greaterVar 	"$one"
		srcVar1		"$mustHeal"
		srcVar2		"$zero"
		resultVar		"$isdown"
	}	

// ========================================================================================================================
// Check if the survivors had a TPK
// ========================================================================================================================		

	LessOrEqual		// If the map restarts after a TPK, it means it restarted and the survivors are not dead
	{			
		LessEqualVar 	"$isdown" 
		greaterVar 	"$zero"
		srcVar1		"$mapRestartTPK"
		srcVar2		"$zero"
		resultVar		"$isdown"
	}

// ========================================================================================================================
// Check if the ENTITY is moving or not
// ========================================================================================================================

	LessOrEqual		// The last check is if the downed survivor ENTITY speed is above 0. If it is, the survivor the code is applied to is moving, and it is thus not down.
	{
		LessEqualVar 	"$isdown" 
		greaterVar 	"$zero"
		srcVar1		"$ismoving"
		srcVar2		"$zero"
		resultVar		"$isdown"
	}


// #######################################################################################################
// BLOCK 7 : INJECTOR FOR $FRAME and $DETAILFRAME - This block injects $frametodisplay found at BLOCK 4 after a series of checks
// #######################################################################################################

// This blocks work by getting the $frametodisplay from BLOCK 4 and passing it through a series of checks. If a check fails, the value of the variable
// that is passed to the next check is set to be the current $frame or $detailframe. If this happens for any check, it means "do not change it this time".
// Therefore, it works a bit like a switch:case where in case the condition is not met means it break to not changing the frame (except we cannot break;)

// ========================================================================================================================
// This blocks gets the correct value to work with for the later injection checks (either the result of BLOCK 4 or the user defined frame if the survivior is down)
// ========================================================================================================================
				
				// If the survivor is down ($isdown > 0), we actually do not take the value of $frametodisplay as a starting point but the user defined $frameIfDown
				// This allows the use of a special frame (or a frame to appear) when the survivor is down. It therefore needs to override the result of BLOCK 4
	LessOrEqual		// This does not check yet if the survivor is down. It just gets the correct value to work with
	{
		LessEqualVar 	"$frametodisplay" 
		greaterVar 	"$frameIfDown"
		srcVar1		"$isdown"
		srcVar2		"$zero"
		resultVar		"$frameIsEntity"	// This is the result and is used as a base (transition variable) for the checks
	}					// Note that this check applies both to $frame and $detailframe as only the next check dissociates them



// ========================================================================================================================
// This block does all the needed checks to see if we need to commit the injection of a frame ($frameIsEntity at this point) or if we need not to
// ========================================================================================================================
//
// At any point, if we need not to commit the injection, the value of our variable will be set to the current $frame or $detailframe, making it stay the same 
//
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Check 1 (Is the survivor an entity ?) 
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


	LessOrEqual		// Ditto for $detailframe
	{
		LessEqualVar 	"$detailframe" 
		greaterVar 	"$frameIsEntity"
		srcVar1		"$rand"
		srcVar2		"$zero"
		resultVar		"$detailframetoinjectTemp"	// This is the result and is used as a transition variable for the next checks	
	}

	// N.b. This block is useful to force the $frame to stay the same after the survivor straight up dies. The "corpse" of the survivor is not an entity
	// and if this block did not exist, the corpse would always use the $rand value 0, therefore causing problems when it comes to RNG.

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Check 2 (Is the survivor down ?) 
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	LessOrEqual
	{
		LessEqualVar 	"$detailframetoinjectTemp" 
		greaterVar 	"$frameIfDown"
		srcVar1		"$isdown"
		srcVar2		"$zero"
		resultVar		"$detailframe"	// FINAL INJECTION OF $DETAILFRAME HERE
	}		

	// N.b. This block is useful to prevent problems caused by the fact that if the survivor is down and near death, its HP will actually go
	// from 100 to 0 when he's down. If this didn't exist, the survivor would magically "heal" when he's down with only 1/4 of its life

// #######################################################################################################
// BLOCK 8 : ALPHA OPERATORS - This block is used to show/hide the model compleltely under various conditions
// #######################################################################################################
// ========================================================================================================================
// This block gets the correct alpha to display in a $alphatodisplay variable, depending on the survivor health
// ========================================================================================================================
				
	LessOrEqual		// If the current health is above "showIfBelowThisHP", it must not show (inject 0), otherwise it must show (inject 1)
	{
		LessEqualVar 	"$one" 
		greaterVar 	"$zero"
		srcVar1		"$healthCurrent"
		srcVar2		"$showIfBelowThisHP"
		resultVar		"$alphatodisplay"
	}

	LessOrEqual		// But if the current health is below $butNotIfBelowThisHP, it must not show (inject 0)
	{
		LessEqualVar 	"$zero" 
		greaterVar 	"$alphatodisplay"
		srcVar1		"$healthCurrent"
		srcVar2		"$butNotIfBelowThisHP"
		resultVar		"$alphatodisplay"
	}

	LessOrEqual		// [V1.2 HOTFIX] If the survivor is down, injects the alpha when it is down
	{
		LessEqualVar 	"$alphatodisplay" 
		greaterVar 	"$alphaIfDown"
		srcVar1		"$isdown"
		srcVar2		"$zero"
		resultVar		"$alphatodisplay"
	}

// ========================================================================================================================
// This block draws RNG using the Player Position (Y coordinate) 
// ========================================================================================================================
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Fmod(100) of $posXABS (returns the remainder of the division by 100 of $posXABS in $randUN)
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	Int			// Stores the integer part of $posXABS in $posXINT
	{
		srcVar1		"$posY"
		resultVar		"$posYINT"
	}	

	Divide			// Divides $posXINT by 100
	{
		srcVar1		"$posYINT"
		srcVar2		"$oh"
		resultVar		"$posYD"	
	}	

	Frac			// Stores the integer part of $posXD in $posXDINT
	{
		srcVar1		"$posYD"        
		resultVar		"$posYDFRAC"
	}	

	Multiply			// Multiples $posXDSUB by 100
	{
		srcVar1		"$posYDFRAC"
		srcVar2		"$oh"
		resultVar		"$randUN"
	}

	LessOrEqual		// Stores $randUN into $randChange each second, when the general $sine wave gets above 1 (see top of BLOCK 3) to create a buffer
	{
		LessEqualVar 	"$randUN" 
		greaterVar 	"$randChange"
		srcVar1		"$sine"
		srcVar2		"$one"
		resultVar		"$randChange"	
	}	

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// This is a sub-block used to store the RNG at the beginning and reroll it each time the survivor is above a certain health level
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

				// If $showIfBelowThisHP < 100, stores $showIfBelowThisHP in $rerollifabove, otherwise stores $butNotIfBelowThisHP
				// At this point $rerollifabove is equal to the value at which the thing usually changes visibility. 
	LessOrEqual		
	{
		LessEqualVar 	"$butNotIfBelowThisHP" 
		greaterVar 	"$showIfBelowThisHP"
		srcVar1		"$oh"
		srcVar2		"$showIfBelowThisHP"
		resultVar		"$rerollifabove"
	}

	LessOrEqual		// This stores the current health of the survivor but stores 0 if he is down (contraty to $healthCurrent that would be 100 in this case)
	{
		LessEqualVar 	"$healthCurrent" 
		greaterVar 	"$zero"
		srcVar1		"$isdown"
		srcVar2		"$zero"
		resultVar		"$healthSpecial"
	}

	LessOrEqual		// If the health is above the value at which the thing usually changes visibility, it sets the value of $randChangeStored to 101 to force a reroll (see next block) 
	{
		LessEqualVar 	"$randChangeStored" 
		greaterVar 	"$oho"
		srcVar1		"$healthSpecial"
		srcVar2		"$rerollifabove"
		resultVar		"$randChangeStored"
	}

	LessOrEqual		// As long as $randChangeStored is above 100, $randChange is stored in it. $randChange defaults at 101 so it's stored once at the beginning, and then later if there's a reroll (see above)
	{
		LessEqualVar 	"$randChangeStored" 
		greaterVar 	"$randChange"
		srcVar1		"$randChangeStored"
		srcVar2		"$oh"
		resultVar		"$randChangeStored"
	}

// ========================================================================================================================
// This block does the necessary checks to inject the $alphatodisplay into $alpha or not 
// ========================================================================================================================
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Check 1 (Is the survivor an entity ?) 
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	LessOrEqual		// If $rand = 0, the material is the dead corpse than cannot generate RNG. In this case, $alpha must not change
	{
		LessEqualVar 	"$alpha" 
		greaterVar 	"$alphatodisplay"
		srcVar1		"$rand"
		srcVar2		"$zero"
		resultVar		"$alphaEntityChecked"	// $alphatodisplay is now stored here for the next check
	}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Check 2 (Does the RNG prevents the change ?) 
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	LessOrEqual		// If the random number between 0 and 100 is lower than $chanceOfChanging, the change must happen. If it's lower, we inject $alpha and it says the same
	{
		LessEqualVar 	"$alphaEntityChecked" 
		greaterVar 	"$alpha"
		srcVar1		"$randChangeStored"
		srcVar2		"$chanceOfChanging"
		resultVar		"$alphaRNGChecked"
	}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Check 3 (Has the $alpha changed and can we revert to the previous one ?) 
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	LessOrEqual		// This determines if the material shows at start. If $showIfBelowThisHP < 100, it does not (store 0 in this case, else 1)
	{
		LessEqualVar 	"$one" 
		greaterVar 	"$zero" 
		srcVar1		"$oh"
		srcVar2		"$showIfBelowThisHP"
		resultVar		"$showFromStart"
	}

	Subtract			// This and the next proxy determines if the current $alpha is different from its initial status ($showFromStart)
	{
		srcVar1		"$alpha"
		srcVar2		"$showFromStart"
		resultVar		"$alphaHasChanged"
	}

	Abs			// If both are the same, it will be either 0-0 = 0 or 1-1 = 0. If they are different, it's either 1-0 = 1 or 0-1 = -1. If we abs() that, value will be 1 if they are different
	{
		srcVar1		"$alphaHasChanged"
		resultVar		"$alphaHasChanged"
	}

	Multiply			// If $alpha has changed (=1) AND if $cannotRevertDefaultAlpha = 1, $forceSameAlpha will be equal to 1
	{
		srcVar1		"$alphaHasChanged"
		srcVar2		"$cannotRevertDefaultAlpha"
		resultVar		"$forceSameAlpha"
	}

	LessOrEqual		// If forceSameAlpha > 0, we do what is says and force the same $alpha as before
	{
		LessEqualVar 	"$alphaRNGChecked" 
		greaterVar 	"$alpha" 
		srcVar1		"$forceSameAlpha"
		srcVar2		"$zero"
		resultVar		"$alphaNRChecked"
	}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Check 4 (Must we force the $alpha is down over everything ?) 
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	Multiply			// If the survivor is down and if $alphaIfDownMaxPriority is set to 1, $forceDownAlpha (user defined) = 1
	{
		srcVar1		"$isdown"
		srcVar2		"$alphaIfDownMaxPriority"
		resultVar		"$forceDownAlpha"
	}

	LessOrEqual		// If $forceDownAlpha is > 0, we actually end up scrapping all the checks and forcing $alphaIfDown into $alpha. Otherwise, we inject $alphaNoRevertChecked
	{
		LessEqualVar 	"$alphaNRChecked" 
		greaterVar 	"$alphaIfDown" 
		srcVar1		"$forceDownAlpha"
		srcVar2		"$zero"
		resultVar		"$alpha"
	}

// #######################################################################################################
// BLOCK 9 : Embed RNG
// #######################################################################################################

	EntityRandom		// This gets a random number between 0 and the amount of skins the user defined
	{
		scale 		"$differentSkins" 
		resultVar 		"$randRNG"
	}

				// If the map has started for less than 30 seconds (due to the above offset), we copy $randRNG in $frameRNG
				// This is used to draw RNG at the beginning of the map even if the survivor is static, because it cannot be dead yet
	LessOrEqual		
	{
		LessEqualVar 	"$frame"
		greaterVar 	"$randRNG"
		srcVar1 		"$ENTJustSpawned"
		srcVar2 		"$zero" 
		resultVar 		"$frameRNG" 
	}
				// We also copy $randRNG in $frameRNG each time the entity (survivor that has damage) moves
				// This prevents the RNG to change if the survivor is now a dead body
	LessOrEqual		
	{
		LessEqualVar 	"$frameRNG"
		greaterVar 	"$randRNG"
		srcVar1 		"$ismoving"
		srcVar2 		"$zero" 
		resultVar 		"$frame" 		// N.b. With the Medium Version, $frame is not in use, it is safe to inject no matter what
	}


}



}
